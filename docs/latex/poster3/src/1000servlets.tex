\section*{1000-Servlets}
\textbf{Experiment mit 1000 Servlets}

In diesem Experiment haben wir 1000 neue Servlet-Dateien 
(\texttt{Servlet1.java} bis \texttt{Servlet1000.java}) in das Repository 
hochgeladen, was insgesamt 13.000 neue Codezeilen umfasste.
Zunächst haben wir mithilfe von \texttt{xargs} pro Aufruf nur 50 Dateien an 
Checkstyle und den Google Java Formatter übergeben. Dabei ergab sich eine hohe 
Wartezeit von etwa \textbf{24,6 Sekunden}, was für 1000 Dateien sehr lang ist.  
Da ein Push abgelehnt wird, sobald Checkstyle Fehler findet, war diese Verzögerung problematisch.
Um die Performance zu verbessern, haben wir unsere Aufrufe angepasst:  
Statt 50 Dateien pro Durchgang übergaben wir nun alle 1000 Dateien auf einmal.  
Zusätzlich wurden nur die \textbf{geänderten} Servlets geprüft, anstatt alle erneut zu analysieren.
\paragraph{Ergebnis:}
\begin{itemize}
    \item \textbf{Vorher:} 24,6 Sekunden (bei \texttt{xargs -n 50})
    \item \textbf{Jetzt:} 10,6 Sekunden (bei \texttt{xargs -n 1000})
\end{itemize}

Die Zeit konnte somit um rund \textbf{60 Prozent} reduziert werden.  
Negative Auswirkungen auf CPU- oder RAM-Auslastung waren nicht zu beobachten.  
Falls dennoch weitere Verzögerungen auftreten, könnte das Netzwerk der Flaschenhals sein.  
Die minimalen \texttt{user} und \texttt{sys}-Zeiten deuten darauf hin, dass die Hauptverzögerung 
auf I/O- und Netzwerkprozesse zurückzuführen ist.
Durch die Verringerung der Checkstyle-Aufrufe (von rund 20 auf 1) hat sich die Push-Zeit 
\textbf{mehr als halbiert}.  
Dieses Experiment zeigt, dass Checkstyle effizienter arbeitet,  
wenn eine große Liste an Dateien in einem Durchgang geprüft wird,  
anstatt viele kleine Prozesse zu starten.  
So konnten wir erfolgreich untersuchen, wie das Repository und der Hook unter Einfluss 
von Checkstyle und Google Java Formatter mit einer großen Anzahl neuer Dateien umgehen.

